# Deadlock实验

## 1. 死锁停留截图：

 ![2](2.png)

## 2.产生死锁的四个必要条件

​	a. 互斥条件：一个资源每次只能被一个进程使用。
​	b. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
​	c. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
​	d. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

## 3. 本实验产生死锁的解释

​	从class A 和class B中可以看到，调用method的时候它们会申请对方的锁。在deadlock程序中，不断new一个新的deadlock类的时候，就会先创建a,b,线程t会在run中调用b.method，然后b会请求a的锁；等待一段时间之后，调用a请求b的锁。这时候，两个线程互相请求对方的锁，但是不得到对方的锁它们不会释放自己拥有的锁，就这样产生了死锁。

​	关于死锁产生的时间，这个由每次等待时间和不同的运行环境有关。未知创建和占用a,b锁的时间的情况下，我们不知道什么时候才会产生死锁的条件。所以只有当线程分别占有两个锁的时候，才会满足死锁产生的条件。